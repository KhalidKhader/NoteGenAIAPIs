---
description: AI System Architecture for SOAP Notes Generation
globs: 
alwaysApply: true
---

# AI System Architecture for Medical SOAP Notes Generation

You are an AI system architect specializing in healthcare AI applications. Your role is to design, implement, and optimize intelligent systems for medical documentation, specifically SOAP notes generation from patient-doctor conversations.

## System Overview

This system converts real-time patient-doctor conversations into structured SOAP notes using advanced AI techniques including:
- Real-time Speech-to-Text (STT) processing
- Sequential prompt engineering with GPT-4o
- Multi-RAG architecture for knowledge management
- Pattern learning for doctor personalization
- SNOMED Canadian edition integration

## Core Architecture Principles

### 1. Microservices Architecture
- **API Gateway**: NestJS backend for request orchestration(We are not building it, its already built, it will pass us, this will pass to us SOAP Templates, System prompts, Custom instructions, Generator section id, Section prompt, Transcription text)
- **AI Services**: Python-based microservices for ML operations
- **RAG Services**: Specialized services for different knowledge domains
- **Event-Driven**: Asynchronous processing with message queues

### 2. Three-Tier RAG System
```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│ Conversation    │    │ SNOMED           │    │ Pattern         │
│ RAG             │    │ RAG              │    │ Learning RAG    │
│ (Sensitive)     │    │ (Medical Terms)  │    │ (Preferences)   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

### 3. Intelligent Chunking Strategy
- **Semantic Chunking**: Medical topic-based segmentation
- **Sliding Window**: Context overlap preservation
- **Hierarchical Retrieval**: Multi-level context extraction

## Technical Stack

### Backend Services
- **Primary API**: NestJS with TypeScript
- **AI Engine**: Python with FastAPI
- **Vector Database**: Weaviate (medical data optimized)
- **Neo4J**: Contains the SNOMED codes as a knowledge graph
- **Message Queue**: Redis for async processing
- **Caching**: Redis for performance optimization

### AI/ML Components
- **LLM**: GPT-4o for SOAP generation
- **Embeddings**: Medical-specific models (BioBERT-based)
- **Chunking**: LangChain with custom medical chunkers
- **STT**: Real-time speech processing

### Security & Compliance
- **Encryption**: AES-256 at rest, TLS 1.3 in transit
- **Access Control**: RBAC with fine-grained permissions
- **Secrets Management**: HashiCorp Vault
- **Compliance**: HIPAA, PIPEDA ready

## SOAP Generation Workflow

### For Short Conversations (5-20 minutes)
```
Conversation → S → S+O → S+O+A → S+O+A+P → S+O+A+P+Keywords
```

### For Long Conversations (1-2 hours)
```
Conversation → Semantic Chunking → Relevant Chunk Retrieval → 
Context-Aware SOAP Generation → Pattern Application → Final Assembly
```

## Key Design Patterns

### 1. Chain of Responsibility
Sequential SOAP section generation with context accumulation

### 2. Strategy Pattern
Different processing strategies for conversation length

### 3. Observer Pattern
Pattern learning from doctor modifications

### 4. Factory Pattern
RAG service instantiation based on data type

## Data Flow Architecture

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   STT       │───▶│  NestJS     │───▶│  Python     │
│  Service    │    │  Gateway    │    │ AI Service  │
└─────────────┘    └─────────────┘    └─────────────┘
                           │                   │
                           ▼                   ▼
                   ┌─────────────┐    ┌─────────────┐
                   │  Frontend   │    │ RAG Services│
                   │   Client    │    │   Cluster   │
                   └─────────────┘    └─────────────┘
```

## Performance Optimization

### Token Management
- **Chunking**: Reduce token usage by 60-80%
- **Context Windows**: Optimize for GPT-4o limits
- **Caching**: Store intermediate results

### Scalability
- **Horizontal Scaling**: Independent service scaling
- **Load Balancing**: Request distribution
- **Connection Pooling**: Database optimization

## Security Considerations

### Data Classification
1. **Highly Sensitive**: Patient conversations, PHI
2. **Sensitive**: SOAP notes, doctor preferences
3. **Internal**: SNOMED codes, system metadata

### Privacy Protection
- **Data Anonymization**: Remove/mask PII where possible
- **Audit Logging**: Complete access trail
- **Encryption**: End-to-end data protection

## Pattern Learning System

### Learning Mechanism
```python
# Example pattern structure
{
  "doctor_id": "doc_123",
  "pattern": {
    "original_term": "Hypertension",
    "preferred_term": "HTN",
    "context": "assessment_section",
    "confidence": 0.95,
    "frequency": 15,
    "last_used": "2024-01-15"
  }
}
```

### Feedback Loop
1. **Capture**: Track doctor modifications
2. **Extract**: Identify consistent preferences
3. **Score**: Weight by frequency and recency
4. **Apply**: Use in future generations

## Implementation Guidelines

### Code Organization
```
src/
├── services/
│   ├── ai-engine/          # Python AI services
│   ├── rag/               # RAG implementations
│   └── pattern-learning/   # Learning algorithms
├── controllers/           # NestJS controllers
├── models/               # Data models
├── utils/                # Utility functions
└── config/               # Configuration
```

### Best Practices
- **Async Processing**: Use queues for heavy operations
- **Error Handling**: Graceful degradation
- **Monitoring**: Comprehensive observability
- **Testing**: Unit, integration, and E2E tests

## Monitoring & Observability

### Key Metrics
- Response times and throughput
- Token usage and costs
- SOAP generation accuracy
- System health indicators

### Alerting
- Performance degradation
- Error rate thresholds
- Security incidents
- Resource utilization

## Development Workflow

### 1. Local Development
- Docker Compose for service orchestration
- Environment-specific configurations
- Hot reloading for development

### 2. Testing Strategy
- Unit tests for individual components
- Integration tests for service interactions
- End-to-end tests for complete workflows

### 3. Deployment
- CI/CD pipelines
- Blue-green deployments
- Automated rollbacks

## Future Enhancements

### Planned Features
- Multi-language support expansion
- Advanced pattern recognition
- Real-time collaboration features
- Mobile application support

### Scalability Roadmap
- Multi-region deployment
- Edge computing integration
- Advanced caching strategies
- ML model optimization

---

## Quick Reference Commands

### Development
```bash
# Start local development
docker-compose up -d

# Run tests
npm run test
python -m pytest

# Deploy to staging
npm run deploy:staging
```

### Monitoring
```bash
# Check service health
curl /health

# View logs
kubectl logs -f deployment/ai-service

# Monitor metrics
open http://localhost:3000/metrics
```
