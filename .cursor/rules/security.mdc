---
description:
globs:
alwaysApply: false
---
# Security Configuration and Best Practices

This document outlines the security configuration and best practices for the NoteGen AI APIs project, with special focus on medical data protection, HIPAA/PIPEDA compliance, and RAG system security.

## Medical Data Security Requirements

### Compliance Standards
- **HIPAA Compliance**: For US healthcare data processing
- **PIPEDA Compliance**: For Canadian healthcare data processing
- **SOC 2 Type II**: Security controls certification
- **ISO 27001**: Information security management

### Data Classification
1. **Highly Sensitive**: Patient conversations, PHI (Protected Health Information)
2. **Sensitive**: Generated SOAP notes, doctor preferences
3. **Internal**: SNOMED codes, system metadata
4. **Public**: Documentation, non-sensitive configurations

## Secret Management

### Local Development
- Use `.env` files for local development only
- Never commit `.env` files to version control
- Use `example.env` as a template (committed to repo)
- Keep `.env` files in your local gitignore

### Production Environments
- Use HashiCorp Vault for all secrets management
- Store all environment variables securely
- Rotate secrets regularly using automated rotation
- Use separate secret namespaces for each environment

### Secret Access Pattern
1. Local Development:
   ```bash
   # .env file
   OPENAI_API_KEY=value
   WEAVIATE_API_KEY=value
   NEO4J_PASSWORD=value
   VAULT_TOKEN=value
   # ... other variables
   ```

2. Production Environments:
   ```json
   // HashiCorp Vault structure
   {
     "openai": {
       "api_key": "value"
     },
     "weaviate": {
       "url": "value",
       "api_key": "value"
     },
     "neo4j": {
       "uri": "value",
       "user": "value",
       "password": "value"
     }
   }
   ```

## Encryption Standards

### Data at Rest
- **AES-256 encryption** for all sensitive data storage
- **Separate encryption keys** for each data classification level
- **Key rotation** every 90 days for highly sensitive data
- **Hardware Security Modules (HSM)** for key management

### Data in Transit
- **TLS 1.3** for all service communications
- **mTLS** for internal service-to-service communication
- **Certificate pinning** for external API calls
- **End-to-end encryption** for patient conversation data

### Encryption Implementation
```python
# Example encryption for patient conversations
class ConversationEncryption:
    def encrypt_conversation(self, conversation: str, patient_id: str) -> str:
        # Use patient-specific encryption key
        key = self.get_patient_encryption_key(patient_id)
        return self.aes_encrypt(conversation, key)
    
    def decrypt_conversation(self, encrypted_data: str, patient_id: str) -> str:
        key = self.get_patient_encryption_key(patient_id)
        return self.aes_decrypt(encrypted_data, key)
```

## Access Control and Authentication

### Role-Based Access Control (RBAC)
```python
# Medical AI specific roles
class MedicalAIRoles:
    DOCTOR = "doctor"
    NURSE = "nurse"
    ADMIN = "admin"
    AI_SERVICE = "ai_service"
    RAG_SERVICE = "rag_service"

# Permissions matrix
PERMISSIONS = {
    "doctor": [
        "read_patient_conversations",
        "read_soap_notes",
        "modify_soap_notes",
        "access_pattern_learning"
    ],
    "ai_service": [
        "read_patient_conversations",
        "write_soap_notes",
        "access_rag_services"
    ],
    "rag_service": [
        "read_conversation_chunks",
        "write_embeddings",
        "access_snomed_data"
    ]
}
```

### Authentication Methods
- **OAuth 2.0 / OpenID Connect** for user authentication
- **Service-to-service tokens** with short expiration (15 minutes)
- **API key authentication** for external integrations
- **Multi-factor authentication** for administrative access

## RAG System Security

### Conversation RAG Security
```python
class ConversationRAGSecurity:
    def store_conversation_chunk(self, chunk: str, metadata: dict):
        # Encrypt chunk before storage
        encrypted_chunk = self.encrypt_sensitive_data(chunk)
        
        # Remove PII from metadata
        sanitized_metadata = self.remove_pii(metadata)
        
        # Store with access controls
        self.vector_db.store(
            data=encrypted_chunk,
            metadata=sanitized_metadata,
            access_level="highly_sensitive"
        )
```

### SNOMED RAG Security
- **Read-only access** to SNOMED knowledge graph
- **Rate limiting** to prevent data extraction
- **Audit logging** for all SNOMED queries
- **IP whitelisting** for Neo4j access

### Pattern Learning RAG Security
- **Doctor-specific isolation** of learned patterns
- **Consent tracking** for pattern learning
- **Data anonymization** where possible
- **Retention policies** for learned patterns

## Audit Logging and Monitoring

### Audit Requirements
```python
class MedicalAuditLogger:
    def log_patient_data_access(self, user_id: str, patient_id: str, action: str):
        audit_entry = {
            "timestamp": datetime.utcnow(),
            "user_id": user_id,
            "patient_id": self.hash_patient_id(patient_id),  # Hash for privacy
            "action": action,
            "ip_address": self.get_client_ip(),
            "user_agent": self.get_user_agent(),
            "session_id": self.get_session_id()
        }
        self.secure_audit_store.log(audit_entry)
```

### Monitoring Alerts
- **Unauthorized access attempts**
- **Unusual data access patterns**
- **Failed authentication attempts**
- **Data export activities**
- **System security events**

## Data Privacy and Anonymization

### PII Detection and Removal
```python
class PIIDetector:
    def detect_and_mask_pii(self, text: str) -> str:
        # Detect common PII patterns
        patterns = {
            'ssn': r'\d{3}-\d{2}-\d{4}',
            'phone': r'\d{3}-\d{3}-\d{4}',
            'email': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
            'date_of_birth': r'\d{1,2}/\d{1,2}/\d{4}'
        }
        
        for pii_type, pattern in patterns.items():
            text = re.sub(pattern, f'[{pii_type.upper()}_MASKED]', text)
        
        return text
```

### Data Retention Policies
- **Patient conversations**: 7 years (medical record retention)
- **SOAP notes**: 7 years (medical record retention)
- **Audit logs**: 10 years (compliance requirement)
- **Pattern learning data**: 2 years (with consent)
- **System logs**: 1 year (operational data)

## Network Security

### Firewall Configuration
```yaml
# Example firewall rules
ingress_rules:
  - port: 443
    protocol: HTTPS
    source: "load_balancer"
  - port: 8080
    protocol: HTTP
    source: "internal_services"
    
egress_rules:
  - destination: "openai_api"
    port: 443
    protocol: HTTPS
  - destination: "weaviate_cluster"
    port: 8080
    protocol: HTTP
```

### VPC Security
- **Private subnets** for all sensitive services
- **NAT gateways** for outbound internet access
- **VPC endpoints** for AWS services
- **Security groups** with least privilege access

## Incident Response

### Security Incident Classification
1. **Critical**: Patient data breach, unauthorized access to PHI
2. **High**: Service compromise, authentication bypass
3. **Medium**: Suspicious activity, failed security controls
4. **Low**: Policy violations, minor security events

### Response Procedures
```python
class SecurityIncidentResponse:
    def handle_data_breach(self, incident_details: dict):
        # Immediate containment
        self.isolate_affected_systems()
        
        # Notification requirements
        self.notify_compliance_team()
        self.notify_affected_patients()  # Within 60 days per HIPAA
        
        # Investigation and remediation
        self.start_forensic_investigation()
        self.implement_remediation_plan()
```

## Compliance Monitoring

### Automated Compliance Checks
- **Daily**: Access control validation
- **Weekly**: Encryption key rotation status
- **Monthly**: Audit log review
- **Quarterly**: Security assessment
- **Annually**: Compliance certification renewal

### Compliance Reporting
```python
class ComplianceReporter:
    def generate_hipaa_report(self) -> dict:
        return {
            "encryption_status": self.check_encryption_compliance(),
            "access_controls": self.validate_access_controls(),
            "audit_logs": self.verify_audit_completeness(),
            "data_retention": self.check_retention_policies(),
            "incident_response": self.review_incident_handling()
        }
```

## Security Testing

### Regular Security Assessments
- **Penetration testing**: Quarterly
- **Vulnerability scanning**: Weekly
- **Code security review**: Every release
- **Access control audit**: Monthly

### Security Testing Checklist
- [ ] Input validation testing
- [ ] Authentication bypass attempts
- [ ] Authorization escalation testing
- [ ] Data encryption verification
- [ ] API security testing
- [ ] Infrastructure security review

## Development Security Guidelines

### Secure Coding Practices
```python
# Example secure coding patterns
class SecureSOAPGenerator:
    def generate_soap_section(self, conversation_data: str, doctor_id: str):
        # Input validation
        if not self.validate_input(conversation_data):
            raise ValidationError("Invalid conversation data")
        
        # Authorization check
        if not self.check_doctor_permissions(doctor_id):
            raise AuthorizationError("Insufficient permissions")
        
        # Secure processing
        with self.security_context(doctor_id):
            return self.process_soap_generation(conversation_data)
```

### Code Review Security Checklist
- [ ] No hardcoded secrets or credentials
- [ ] Proper input validation and sanitization
- [ ] Secure error handling (no information leakage)
- [ ] Appropriate access controls
- [ ] Encryption for sensitive data
- [ ] Audit logging for security events